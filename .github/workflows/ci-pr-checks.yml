name: CI - Fast PR Checks

# Purpose: Fast feedback for pull requests using pre-built Docker image
# Strategy:
#   1. Use pre-compiled Docker image (ghcr.io/formingworlds/proteus:latest)
#   2. Overlay PR code changes onto the container
#   3. Smart rebuild: Only recompile changed source files (make handles this)
#   4. Run @pytest.mark.unit tests with mocked physics (fast, ~2-5 min total)
#   5. Run @pytest.mark.smoke tests with real binaries (1 timestep, low res, ~2-5 min)
#   6. Exclude placeholder tests (@pytest.mark.skip) - these are placeholders for future implementation
#
# Test Categories:
#   @pytest.mark.unit    -> Fast tests with mocked physics (target: <100ms each)
#   @pytest.mark.smoke   -> Quick validation with real binaries (target: <30s each)
#   @pytest.mark.skip    -> Placeholder tests not yet implemented (excluded from CI)
#
# For current test counts and detailed metrics, see: docs/test_infrastructure.md

on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering for testing

permissions:
  contents: write  # Allow auto-commit of ratcheted coverage thresholds
  packages: read
  actions: read  # Required to download artifact from last nightly run

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: formingworlds/proteus

jobs:
  unit-tests:
    name: Unit Tests (Mocked Physics)
    runs-on: ubuntu-latest
    outputs:
      unit-outcome: ${{ steps.unit-tests.outcome }}
      smoke-outcome: ${{ steps.smoke-tests.outcome }}
      coverage-status: ${{ steps.coverage-validation.outputs.coverage_status }}
      coverage-drop: ${{ steps.coverage-validation.outputs.coverage_drop }}
      estimated-total: ${{ steps.coverage-validation.outputs.estimated_total }}
      threshold: ${{ steps.coverage-validation.outputs.threshold }}
      nightly-stale: ${{ steps.check-nightly.outputs.nightly_stale }}
      nightly-missing: ${{ steps.check-nightly.outputs.nightly_missing }}
      unit-pct: ${{ steps.coverage-validation.outputs.unit_pct }}
      unit-covered: ${{ steps.coverage-validation.outputs.unit_covered }}
      unit-total: ${{ steps.coverage-validation.outputs.unit_total }}
      nightly-pct: ${{ steps.coverage-validation.outputs.nightly_pct }}
      est-covered-union: ${{ steps.coverage-validation.outputs.est_covered_union }}
      est-total-union: ${{ steps.coverage-validation.outputs.est_total_union }}
    container:
      image: ghcr.io/formingworlds/proteus:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      # NOTE: Running as root is required because the Docker image installs to
      # system paths (/opt/proteus) and actions/checkout needs workspace write access.
      options: --user root

    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prevent threshold decreases vs main
        run: |
          git config --global --add safe.directory /__w/PROTEUS/PROTEUS
          git fetch origin main
          python - <<'PY'  # Heredoc: inline Python script (PY marks start/end)
          import pathlib
          import subprocess
          import tomllib

          base = "origin/main"
          current = tomllib.loads(pathlib.Path("pyproject.toml").read_text())
          base_text = subprocess.check_output(["git", "show", f"{base}:pyproject.toml"], text=True)
          base_data = tomllib.loads(base_text)

          paths = {
              "full": ["tool", "coverage", "report", "fail_under"],
              "fast": ["tool", "proteus", "coverage_fast", "fail_under"],
          }

          def get_val(data, path):
              try:
                  for key in path:
                      data = data[key]
              except KeyError:
                  return None
              return float(data)

          for label, path in paths.items():
              cur = get_val(current, path)
              base_val = get_val(base_data, path)

              if base_val is None or cur is None:
                  print(f"Skipping {label} check (missing in base or current)")
                  continue

              if cur < base_val:
                  raise SystemExit(f"{label} fail_under decreased: {cur} < {base_val}")

          print("Coverage thresholds have not decreased vs main.")
          PY

      - name: Overlay PR code onto container
        run: |
          echo "Copying PR code over container base..."
          rsync -av --exclude='.git' --exclude='SPIDER' --exclude='socrates' --exclude='petsc' --exclude='AGNI' . /opt/proteus/
          cd /opt/proteus
          pip install -e ".[develop]" --no-deps

      - name: Install CI helper tools
        run: |
          cd /opt/proteus
          pip install diff-cover

      - name: Read fast coverage threshold
        run: |
          cd /opt/proteus
          python - <<'PY' >> "$GITHUB_ENV"
          import pathlib
          import tomllib

          data = tomllib.loads(pathlib.Path("pyproject.toml").read_text())
          val = float(data["tool"]["proteus"]["coverage_fast"]["fail_under"])
          print(f"FAST_COV_FAIL_UNDER={val}")
          PY

      - name: Validate test structure
        run: |
          cd /opt/proteus
          bash tools/validate_test_structure.sh

      - name: Run unit tests with coverage
        id: unit-tests
        continue-on-error: true
        run: |
          cd /opt/proteus
          # Run unit tests, excluding placeholder tests and examples
          pytest -m "unit and not skip" \
            --ignore=tests/examples \
            --cov=src --cov-report=term-missing --cov-report=xml --cov-report=html \
            --cov-fail-under=${FAST_COV_FAIL_UNDER} \
            --durations=0 \
            --durations-min=0 | tee pytest-unit.log

      - name: Smart rebuild of physics modules
        run: |
          cd /opt/proteus
          echo "Checking if Fortran/C source files changed..."

          # SOCRATES rebuild (only if sources changed)
          if [ -d "socrates" ]; then
            cd socrates
            ./build_code 2>&1 | grep -q "Nothing to be done" || {
              echo "SOCRATES needs rebuild..."
              ./build_code
            }
            cd /opt/proteus
          fi

          # AGNI rebuild (only if Julia sources changed)
          if [ -d "AGNI" ]; then
            cd AGNI
            if git diff --name-only HEAD origin/main | grep -q '\.jl$'; then
              echo "AGNI Julia sources changed, re-instantiating packages..."
              julia -e 'using Pkg; Pkg.activate("."); Pkg.instantiate()'
            else
              echo "No AGNI changes detected, skipping rebuild"
            fi
            cd /opt/proteus
          fi

      - name: Run smoke tests (append to coverage)
        id: smoke-tests
        continue-on-error: true
        run: |
          cd /opt/proteus
          pytest -m "smoke and not skip" \
            --ignore=tests/examples \
            --cov=src --cov-append \
            --cov-report=term-missing --cov-report=xml --cov-report=html \
            --durations=0 \
            --durations-min=0 -v --tb=short | tee pytest-smoke.log

      - name: Generate coverage JSON
        run: |
          cd /opt/proteus
          # Use --fail-under=0 to prevent failure when fast coverage < full threshold
          coverage json -o coverage-unit.json --fail-under=0

      - name: Download last nightly coverage (for estimated total)
        id: download-nightly
        if: always()
        continue-on-error: true  # Do not fail job when no nightly artifact exists yet
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci-nightly.yml
          name: nightly-coverage
          path: nightly-coverage
          workflow_conclusion: success
          if_no_artifact_found: warn

      - name: Copy nightly coverage into container and check staleness
        id: check-nightly
        if: always()
        run: |
          cd /opt/proteus
          STALE_HOURS=48
          NIGHTLY_STALE=false
          NIGHTLY_MISSING=false

          if [ -f /__w/PROTEUS/PROTEUS/nightly-coverage/coverage-integration-only.json ]; then
            cp /__w/PROTEUS/PROTEUS/nightly-coverage/coverage-integration-only.json /opt/proteus/
            cp /__w/PROTEUS/PROTEUS/nightly-coverage/nightly-timestamp.txt /opt/proteus/ 2>/dev/null || true
            cp /__w/PROTEUS/PROTEUS/nightly-coverage/coverage-by-type.json /opt/proteus/ 2>/dev/null || true

            # Check staleness
            if [ -f /opt/proteus/nightly-timestamp.txt ]; then
              NIGHTLY_TS=$(cat /opt/proteus/nightly-timestamp.txt)
              python3 - <<PYEOF
          from datetime import datetime, timezone, timedelta
          import sys
          ts = datetime.fromisoformat("$NIGHTLY_TS".replace('Z', '+00:00'))
          age = datetime.now(timezone.utc) - ts
          hours = age.total_seconds() / 3600
          print(f"Nightly artifact age: {hours:.1f} hours")
          if hours > $STALE_HOURS:
              print(f"WARNING: Nightly artifact is stale ({hours:.1f}h > {$STALE_HOURS}h)")
              sys.exit(1)
          print("Nightly artifact is fresh.")
          PYEOF
              if [ $? -ne 0 ]; then
                NIGHTLY_STALE=true
              fi
            else
              echo "No timestamp file found - assuming fresh"
            fi
          else
            echo "No nightly coverage artifact found"
            NIGHTLY_MISSING=true
          fi

          echo "NIGHTLY_STALE=$NIGHTLY_STALE" >> $GITHUB_ENV
          echo "NIGHTLY_MISSING=$NIGHTLY_MISSING" >> $GITHUB_ENV
          echo "nightly_stale=$NIGHTLY_STALE" >> $GITHUB_OUTPUT
          echo "nightly_missing=$NIGHTLY_MISSING" >> $GITHUB_OUTPUT

      - name: Validate coverage and write outputs
        id: coverage-validation
        if: always()
        env:
          NIGHTLY_STALE: ${{ env.NIGHTLY_STALE }}
          NIGHTLY_MISSING: ${{ env.NIGHTLY_MISSING }}
        run: |
          cd /opt/proteus
          python - <<'PY'
          import json
          import os
          import pathlib
          import tomllib

          GRACE_PERIOD = 0.3  # Allow coverage drops up to this margin

          def read_totals(path):
              try:
                  with open(path) as f:
                      data = json.load(f)
                  t = data.get("totals", {})
                  return t.get("percent_covered", 0), t.get("covered_lines", 0), t.get("num_statements", 0)
              except Exception:
                  return 0, 0, 0

          def norm_path(p):
              p = p.replace("\\", "/")
              if "proteus/" in p:
                  return "proteus/" + p.split("proteus/", 1)[-1]
              if "src/" in p:
                  return p.split("src/", 1)[-1]
              return p

          def line_set_from_files(data):
              out = set()
              for path, fd in data.get("files", {}).items():
                  n = norm_path(path)
                  for line in fd.get("executed_lines", []) or []:
                      out.add((n, line))
              return out

          def executable_set_from_files(data):
              out = set()
              for path, fd in data.get("files", {}).items():
                  n = norm_path(path)
                  for line in (fd.get("executed_lines", []) or []) + (fd.get("missing_lines", []) or []):
                      out.add((n, line))
              return out

          # Read thresholds from pyproject.toml
          try:
              pyproject = tomllib.loads(pathlib.Path("pyproject.toml").read_text())
              full_threshold = float(pyproject["tool"]["coverage"]["report"]["fail_under"])
          except Exception:
              full_threshold = 59.0  # Fallback (matches pyproject.toml)

          # Read coverage data
          u_pct, u_covered, u_total = read_totals(pathlib.Path("coverage-unit.json"))
          u_data = {}
          try:
              if pathlib.Path("coverage-unit.json").exists():
                  u_data = json.loads(pathlib.Path("coverage-unit.json").read_text())
          except (json.JSONDecodeError, OSError):
              pass

          # NOTE: Despite the filename, coverage-integration-only.json actually contains
          # COMBINED coverage (unit + smoke + integration) from nightly. See ci-nightly.yml.
          # TODO: Potential coverage math issue - stale nightly lines could mask PR regressions.
          i_data = {}
          try:
              if pathlib.Path("coverage-integration-only.json").exists():
                  i_data = json.loads(pathlib.Path("coverage-integration-only.json").read_text())
          except (json.JSONDecodeError, OSError):
              pass
          i_pct, i_covered, i_total = read_totals(pathlib.Path("coverage-integration-only.json"))

          # Compute estimated total (union)
          est_pct_union = None
          est_covered_union = 0
          est_total_union = 0
          if u_data.get("files") and i_data.get("files"):
              u_exec = line_set_from_files(u_data)
              i_exec = line_set_from_files(i_data)
              u_all = executable_set_from_files(u_data)
              i_all = executable_set_from_files(i_data)
              union_covered = u_exec | i_exec
              union_executable = u_all | i_all
              if union_executable:
                  est_covered_union = len(union_covered)
                  est_total_union = len(union_executable)
                  est_pct_union = min(100.0, 100.0 * est_covered_union / est_total_union)

          # Check staleness and coverage status
          nightly_stale = os.environ.get("NIGHTLY_STALE", "false") == "true"
          nightly_missing = os.environ.get("NIGHTLY_MISSING", "false") == "true"

          # Determine coverage status
          coverage_status = "ok"
          coverage_drop = 0
          if est_pct_union is not None:
              coverage_drop = full_threshold - est_pct_union
              if coverage_drop > GRACE_PERIOD:
                  coverage_status = "fail"
              elif coverage_drop > 0:
                  coverage_status = "warn"

          # Write outputs for subsequent steps and summary job
          output_file = pathlib.Path(os.environ.get("GITHUB_OUTPUT", "/tmp/outputs.txt"))
          est_total_str = f"{est_pct_union:.2f}" if est_pct_union is not None else "0"
          with open(output_file, "a") as f:
              f.write(f"coverage_status={coverage_status}\n")
              f.write(f"coverage_drop={coverage_drop:.2f}\n")
              f.write(f"estimated_total={est_total_str}\n")
              f.write(f"threshold={full_threshold}\n")
              f.write(f"unit_pct={u_pct:.2f}\n")
              f.write(f"unit_covered={u_covered}\n")
              f.write(f"unit_total={u_total}\n")
              f.write(f"nightly_pct={i_pct:.2f}\n")
              f.write(f"est_covered_union={est_covered_union}\n")
              f.write(f"est_total_union={est_total_union}\n")

          # Print summary to log
          disp_est = f"{est_pct_union:.2f}%" if est_pct_union else "—"
          print(f"Unit+Smoke: {u_pct:.2f}% | Nightly: {i_pct:.2f}% | Estimated total: {disp_est} | Status: {coverage_status}")
          PY

      - name: Diff coverage on changed lines (fast suite)
        id: diff-cover
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref || 'main' }}
        run: |
          # Fetch base branch and generate diff file to avoid remote fetch issues in container
          cd /__w/PROTEUS/PROTEUS
          git fetch --no-tags --prune --depth=100 origin "${BASE_REF}"
          git diff "origin/${BASE_REF}...HEAD" > /tmp/pr-changes.diff

          # Run diff-cover using the prepared diff file
          diff-cover /opt/proteus/coverage.xml --diff-file /tmp/pr-changes.diff --fail-under=80

      - name: Post coverage warning comment on PR
        if: github.event_name == 'pull_request' && steps.coverage-validation.outputs.coverage_status == 'warn'
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            ## ⚠️ Coverage Warning

            This PR reduces test coverage by **${{ steps.coverage-validation.outputs.coverage_drop }}%** (from ${{ steps.coverage-validation.outputs.threshold }}% to ${{ steps.coverage-validation.outputs.estimated_total }}%).

            While this is within the **0.3% grace margin** and won't block merge, we encourage you to add tests in a follow-up PR to restore coverage above ${{ steps.coverage-validation.outputs.threshold }}%.

            **How to fix:** Add unit tests for the new/changed code paths.
            See [test_building.md](https://github.com/FormingWorlds/PROTEUS/blob/main/docs/test_building.md) for guidance.

      - name: Fail job if nightly is stale
        if: always() && steps.check-nightly.outcome == 'success'
        run: |
          if [ "$NIGHTLY_STALE" = "true" ]; then
            echo "❌ Nightly baseline is stale (>48 hours old). Cannot validate coverage."
            echo "Trigger nightly CI manually: https://github.com/FormingWorlds/PROTEUS/actions/workflows/ci-nightly.yml"
            exit 1
          fi

      - name: Fail job if coverage dropped beyond grace period
        if: always() && steps.coverage-validation.outputs.coverage_status == 'fail'
        run: |
          echo "❌ Coverage dropped by ${{ steps.coverage-validation.outputs.coverage_drop }}% (exceeds 0.3% grace margin)"
          echo "Add tests to restore coverage above ${{ steps.coverage-validation.outputs.threshold }}%"
          exit 1

      - name: Fail job if unit or smoke tests failed
        if: always() && (steps.unit-tests.outcome == 'failure' || steps.smoke-tests.outcome == 'failure')
        run: exit 1

      - name: Ratchet fast coverage threshold
        run: |
          cd /opt/proteus
          # Exit codes: 0=updated, 1=no update needed, 2=error
          # Treat both 0 and 1 as success
          python tools/update_coverage_threshold.py --coverage-file coverage-unit.json --target fast || [ $? -eq 1 ]

      - name: Commit ratcheted threshold (if changed)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        continue-on-error: true
        run: |
          cd /__w/PROTEUS/PROTEUS
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Copy updated pyproject.toml from container to workspace
          cp /opt/proteus/pyproject.toml /__w/PROTEUS/PROTEUS/pyproject.toml

          # Check if there are changes
          if git diff --quiet pyproject.toml; then
            echo "No threshold changes to commit"
          else
            git add pyproject.toml
            COVERAGE=$(grep -A5 '\[tool.proteus.coverage_fast\]' pyproject.toml | grep 'fail_under' | awk '{print $3}')
            git commit -m "ratchet: Auto-update fast coverage threshold to ${COVERAGE}% [skip ci]"
            git push
            echo "✓ Committed ratcheted threshold: ${COVERAGE}%"
          fi

      - name: Install gpg for Codecov verification
        if: always()
        run: |
          apt-get update
          apt-get install -y gnupg

      - name: Upload coverage report
        uses: codecov/codecov-action@v4
        if: always()
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: /opt/proteus/coverage.xml
          flags: unit-tests
          name: unit-tests-coverage
          fail_ci_if_error: false

      - name: Upload HTML coverage
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: unit-coverage-html
          path: /opt/proteus/htmlcov/
          retention-days: 7

      - name: Upload unit pytest log
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: unit-pytest-log
          path: /opt/proteus/pytest-unit.log
          retention-days: 7

      - name: Upload smoke pytest log
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: smoke-pytest-log
          path: /opt/proteus/pytest-smoke.log
          retention-days: 7

      - name: Upload smoke test artifacts on failure
        uses: actions/upload-artifact@v6
        if: failure() && steps.smoke-tests.outcome == 'failure'
        with:
          name: smoke-test-failures
          path: |
            /opt/proteus/output/
            /opt/proteus/tests/**/*.log
          retention-days: 7

  macos-unit-tests:
    name: Unit Tests macOS
    runs-on: macos-latest
    outputs:
      unit-outcome: ${{ steps.unit-tests.outcome }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install PROTEUS
        run: |
          pip install -e ".[develop]"

      - name: Run unit tests
        id: unit-tests
        continue-on-error: true
        run: |
          pytest -m "unit and not skip" \
            --ignore=tests/examples \
            --durations=0 \
            --durations-min=0 | tee pytest-unit-macos.log

      - name: Upload macOS pytest log
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: unit-pytest-log-macos
          path: pytest-unit-macos.log
          retention-days: 7

      - name: Fail job if unit tests failed
        if: always() && steps.unit-tests.outcome == 'failure'
        run: exit 1

  lint:
    name: Code Quality (ruff)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install ruff
        run: pip install ruff

      - name: Run ruff check
        run: ruff check src/ tests/

      - name: Run ruff format check
        run: ruff format --check src/ tests/

  summary:
    name: PR Summary
    runs-on: ubuntu-latest
    if: always()
    needs: [unit-tests, macos-unit-tests, lint]

    steps:
      - name: Write combined summary
        env:
          LINUX_UNIT: ${{ needs.unit-tests.outputs.unit-outcome }}
          LINUX_SMOKE: ${{ needs.unit-tests.outputs.smoke-outcome }}
          LINUX_JOB_RESULT: ${{ needs.unit-tests.result }}
          MACOS_UNIT: ${{ needs.macos-unit-tests.outputs.unit-outcome }}
          MACOS_JOB_RESULT: ${{ needs.macos-unit-tests.result }}
          LINT: ${{ needs.lint.result }}
          COV_STATUS: ${{ needs.unit-tests.outputs.coverage-status }}
          COV_DROP: ${{ needs.unit-tests.outputs.coverage-drop }}
          EST_TOTAL: ${{ needs.unit-tests.outputs.estimated-total }}
          THRESHOLD: ${{ needs.unit-tests.outputs.threshold }}
          NIGHTLY_STALE: ${{ needs.unit-tests.outputs.nightly-stale }}
          NIGHTLY_MISSING: ${{ needs.unit-tests.outputs.nightly-missing }}
          UNIT_PCT: ${{ needs.unit-tests.outputs.unit-pct }}
          UNIT_COVERED: ${{ needs.unit-tests.outputs.unit-covered }}
          UNIT_TOTAL: ${{ needs.unit-tests.outputs.unit-total }}
          NIGHTLY_PCT: ${{ needs.unit-tests.outputs.nightly-pct }}
          EST_COVERED_UNION: ${{ needs.unit-tests.outputs.est-covered-union }}
          EST_TOTAL_UNION: ${{ needs.unit-tests.outputs.est-total-union }}
        run: |
          python3 - <<'PY'
          import os

          def icon(outcome):
              if outcome == "success":
                  return "✅ pass"
              elif outcome == "failure":
                  return "❌ FAIL"
              elif outcome == "skipped":
                  return "⏭️ skipped"
              return outcome or "—"

          summary_path = os.environ.get("GITHUB_STEP_SUMMARY", "/tmp/summary.md")
          nightly_stale = os.environ.get("NIGHTLY_STALE", "false") == "true"
          nightly_missing = os.environ.get("NIGHTLY_MISSING", "false") == "true"
          cov_status = os.environ.get("COV_STATUS", "")
          cov_drop = float(os.environ.get("COV_DROP", "0") or "0")

          linux_unit = os.environ.get("LINUX_UNIT", "")
          linux_smoke = os.environ.get("LINUX_SMOKE", "")
          linux_job_result = os.environ.get("LINUX_JOB_RESULT", "")
          macos_unit = os.environ.get("MACOS_UNIT", "")
          macos_job_result = os.environ.get("MACOS_JOB_RESULT", "")
          lint = os.environ.get("LINT", "")

          with open(summary_path, "w") as f:
              f.write("# Fast PR Checks – Summary\n\n")

              # Staleness/missing warnings
              if nightly_stale:
                  f.write("## ❌ Stale Nightly Baseline\n\n")
                  f.write("The last successful nightly CI run was **more than 48 hours ago**.\n")
                  f.write("Cannot validate coverage against an outdated baseline.\n\n")
                  f.write("**Action required:** Wait for nightly CI to run, or ")
                  f.write("[trigger it manually](https://github.com/FormingWorlds/PROTEUS/actions/workflows/ci-nightly.yml).\n\n")
              elif nightly_missing:
                  f.write("## ⚠️ No Nightly Baseline\n\n")
                  f.write("No nightly coverage artifact found. Coverage validation skipped.\n\n")

              # Coverage warning
              if cov_status == "warn":
                  f.write(f"## ⚠️ Coverage Warning\n\n")
                  f.write(f"Coverage dropped **{cov_drop:.2f}%** (within 0.3% grace margin).\n")
                  f.write("Consider adding tests in a follow-up PR.\n\n")

              # Test results - with platform column
              f.write("## Test Results\n\n")
              f.write("| Platform | Test Type | Status |\n")
              f.write("|----------|-----------|--------|\n")
              f.write(f"| Linux | Unit tests | {icon(linux_unit)} |\n")
              f.write(f"| Linux | Smoke tests | {icon(linux_smoke)} |\n")
              f.write(f"| macOS | Unit tests | {icon(macos_unit)} |\n")
              f.write(f"| — | Lint (ruff) | {icon(lint)} |\n\n")

              # Coverage section (Linux data only)
              unit_pct = float(os.environ.get("UNIT_PCT", "0") or "0")
              unit_covered = os.environ.get("UNIT_COVERED", "0")
              unit_total = os.environ.get("UNIT_TOTAL", "0")
              nightly_pct = float(os.environ.get("NIGHTLY_PCT", "0") or "0")
              est_total = os.environ.get("EST_TOTAL", "")
              est_covered_union = os.environ.get("EST_COVERED_UNION", "0")
              est_total_union = os.environ.get("EST_TOTAL_UNION", "0")
              threshold = float(os.environ.get("THRESHOLD", "0") or "0")

              f.write("## Coverage by Test Type (Linux)\n\n")
              f.write("| Test Type | Coverage | Lines Covered |\n")
              f.write("|-----------|----------|---------------|\n")
              f.write(f"| Unit + Smoke (this PR) | {unit_pct:.2f}% | {unit_covered} / {unit_total} |\n")
              if nightly_pct > 0:
                  f.write(f"| Integration (nightly) | {nightly_pct:.2f}% | — |\n")
              est = float(est_total or "0")
              if est > 0:
                  status_icon = "✅" if cov_status == "ok" else ("⚠️" if cov_status == "warn" else "❌")
                  f.write(f"| **Estimated TOTAL** | **{est:.2f}%** | {est_covered_union} / {est_total_union} |\n\n")
                  f.write(f"**Baseline (last nightly):** {threshold:.2f}% | **Status:** {status_icon}\n\n")
              else:
                  f.write("\n*Estimated total unavailable (nightly data missing)*\n\n")

              f.write("### Notes\n")
              f.write("- macOS runs unit tests only (no smoke tests — requires compiled binaries)\n")
              f.write("- Coverage thresholds enforced on Linux only (source of truth)\n")
              f.write("- Grace period: 0.3% | Nightly staleness threshold: 48 hours\n")
              f.write("- See `docs/test_infrastructure.md` for testing strategy.\n")

              # Failure guidance - includes non-test failures (diff-cover, coverage, staleness)
              any_test_fail = linux_unit == "failure" or linux_smoke == "failure" or macos_unit == "failure"
              # Detect non-test failures: job failed but specific test steps didn't fail
              linux_non_test_fail = (linux_job_result == "failure" and
                                     linux_unit != "failure" and linux_smoke != "failure")
              macos_non_test_fail = macos_job_result == "failure" and macos_unit != "failure"
              cov_fail = cov_status == "fail"

              if any_test_fail or lint == "failure" or linux_non_test_fail or macos_non_test_fail or cov_fail or nightly_stale:
                  f.write("\n---\n")
                  f.write("## ❌ PR did not pass checks\n\n")
                  if any_test_fail:
                      f.write("**Unit tests or smoke tests failed.** See the logs above for details.\n\n")
                      f.write("See **[How to create more unit tests](https://github.com/FormingWorlds/PROTEUS/blob/main/docs/test_building.md)** for guidance.\n\n")
                  if lint == "failure":
                      f.write("**Lint (ruff) failed.** Run `ruff check --fix src/ tests/ && ruff format src/ tests/` locally.\n\n")
                  if linux_non_test_fail:
                      f.write("**Linux job failed on non-test step** (diff-cover, coverage validation, or other check).\n")
                      f.write("Check the 'Unit Tests (Mocked Physics)' job logs for details.\n\n")
                  if cov_fail:
                      f.write(f"**Coverage dropped too much** ({cov_drop:.2f}% below threshold, exceeds 0.3% grace margin).\n")
                      f.write("Add tests to restore coverage above the threshold.\n\n")
                  if nightly_stale:
                      f.write("**Nightly baseline is stale.** Coverage validation cannot proceed.\n")
                      f.write("[Trigger nightly CI manually](https://github.com/FormingWorlds/PROTEUS/actions/workflows/ci-nightly.yml).\n\n")
          PY

      - name: Fail if any checks failed
        if: >-
          needs.unit-tests.result == 'failure' ||
          needs.macos-unit-tests.result == 'failure' ||
          needs.lint.result == 'failure'
        run: |
          echo "❌ One or more required checks failed. See summary above for details."
          exit 1
